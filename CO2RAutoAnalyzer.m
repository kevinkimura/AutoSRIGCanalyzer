%% CO2R Autoanalyzer
% This code will take the GC .ASC files, NMR data, and EC data from the
% echem experiment and automatically analyze the data and generate the
% relevant graph. This code was not meant to be used as a black-box. The
% user should understand the gist of the code and modify as needed. If the
% data output does not look 'normal' ask yourself first, where in the code
% could've the processing not worked?
%
% Developed by Kevin Kimura (2019) while part of Prof. Tobias Hanrath's Lab
% at Cornell University

%% Setting up the Analysis
% 
% All initial parameters need to be inputted in this section manually.
%
% * Electrode name
% * Experimental parameters
% * GCstartdelay: when the GC runs were started
% * GCrunrest: the total time for the GC run and rest in between
% * Leftend: the GC run # which you want to start evaluating from
% * Rightend: the GC run # which you want to end the evaluation
% * Prodnum: number of products to analyze
%
clear; 
clc; close all;
electrode_name = ['AuFoil13'];
exp_parameters = ['-1400_0mVps1s1s'];
GCstartdelay = 10; %min
GCrunrest = 24; %18 min run time and 10 min rest time
Leftend = 1;
Rightend = 5;
Area = 0.2; %probably need to change
Prodnum = 5; %H2, CO, CH4, C2H4, formic, EtOH
pulsing = true;

%% Establishing Experimental time
% Based on inputs above, this section establishes the experimentally
% evaluated time.
% CompiledData: is a blank matrix, which is setup depending on how many
% products are expected.

CompiledData = zeros((Rightend-Leftend),Prodnum); %H2, CO, CH4, C2H4, formic, EtOH
if Leftend == 1
    ExpTime = GCstartdelay:GCrunrest:((Rightend-1)*GCrunrest+GCstartdelay);
else %when you don't start at FID01
    ExpTime = (GCstartdelay+(Leftend-1)*GCrunrest):GCrunrest:((Rightend-1)*GCrunrest+GCstartdelay);
end
Len = length(ExpTime);
	
%% Auto SRIGC run analysis
% 
% User must: 
%
% * Make sure the Calibration data is up-to-date, file path is correct
%   calibration .m file should be run if the calibration file has
%   not been generated.
%
%  GCAutoAnalyzerCALIBRATIONS.m
%
% * products: All product names (string) should be listed
% * product_colors: For each product listed, choose a desired color scheme
% * n: number of electrons used to produce this product.
% * flowrate: units in sccm. If 7% flow rate, then 1.4 sccm
% * CatholyteVol: the volume of the catholyte used
% * In the For loop the user must change the GCFID and GCTCD file paths up
%   to '...FID' or '...TCD' the value after will automatically change
%   depending on the loop number to sample all GC files desired.
%
% _This section may take the longest depending on the number of GC runs
% being analyzed. If you would like to run this whole code multiple times
% without having to reanalyze the GC data each time, uncomment the save .mat
% line, run the code, then comment the for-loop and save .mat lines. Finally
% uncomment the load line. Loading a .mat file will be much faster._
%
%  save('CompiledData.mat','CompiledData') 
%  load('CompiledData.mat');
%

%user inputs
Calibration = importdata(['C:\Users\Kevin\Documents\Graduate_Work_MAIN\Electrochemistry\Data\GCData_analyzer\Autogenerated_Calibration.csv']); %
products = ["H_2","CO","CH_4","C_2H_4","HCOOH"];
product_colors = [1 0 0; 1 0.6 0; 0 0.498 0; 0.4 0.6 1; 0.4 0.2 1];
n = [2 2 8 12 2];
flowrate = 1.4; %sccm
CatholyteVol = 15; %mL

%Constants
SampVol = 10; %mL
SampMol = 101.325*10/(100*8.314*300); 
F = 96485; %faraday's constant
Pressure = 14.7; %psi
v = F*Pressure*6.8976/(8.314*300*60*1000);
molarflow = flowrate*Pressure*6.8976/(8.314*300*1000);

count = 1;
for i = Leftend:Rightend
    %Work in progress to automate the SRI GC
    run_num = i; %choose the desired run #
    if run_num < 10
        runstr = [num2str(0),num2str(run_num)];
    else
        runstr = num2str(run_num);
    end 

    %import the .ASC file (user must specify path)
    GCFID = importdata(['C:\Users\Kevin\Documents\Graduate_Work_MAIN\Electrochemistry\Data\AuFoil Tests\191106AuFoil13ps\GCdata\191106KK AuFoil13 100mM KHCO3 1400mV 0mV ps1s FID',runstr,'.ASC']); %
    GCTCD = importdata(['C:\Users\Kevin\Documents\Graduate_Work_MAIN\Electrochemistry\Data\AuFoil Tests\191106AuFoil13ps\GCdata\191106KK AuFoil13 100mM KHCO3 1400mV 0mV ps1s TCD',runstr,'.ASC']); %

    GCtime = 0.2/60:0.2/60:16; %last value is the total minutes, 5Hz intervals
    H2peak1 = 0.8067; %first H2 peak location
    CH4peak1 = 2.6; %first CH4 peak location
    COpeak1 = 3.476; %first CO peak location
    CH4peak2 = 8.283; %second CH4 peak location
    C2H4peak1 = 10.8; %C2H4 peak location

    H2peak1Area = H2peak1AreaFinder(H2peak1, GCtime, GCTCD.data);
    CH4peak1Area = CH4peak1AreaFinder(CH4peak1, GCtime, GCFID.data);
    COpeak1Area = COpeak1AreaFinder(COpeak1, GCtime, GCFID.data);
    CH4peak2Area = CH4peak2AreaFinder(CH4peak2, GCtime, GCFID.data, 55, 25, 20, 55);
    C2H4peak1Area = C2H4peak1AreaFinder(C2H4peak1, GCtime, GCFID.data, 200, 80, 60, 120);

    H2ppm = H2peak1Area*Calibration(1);
    CH4peak1ppm = CH4peak1Area*Calibration(2);
    COppm = COpeak1Area*Calibration(3);
    CH4peak2ppm = CH4peak2Area*Calibration(4);
    C2H4ppm = C2H4peak1Area*Calibration(5);

    
    CompiledData(count,:) = [H2ppm COppm (CH4peak2ppm+CH4peak1ppm)/2 C2H4ppm zeros(1,Prodnum-4)];
    count = count +1;
end
% save('CompiledData.mat','CompiledData') 
% load('CompiledData.mat');

CompiledData = CompiledData/1000000;  %convert all ppm to x_i


%% NMR Analysis section
% 
% This portion takes the NMR data in a column format .xlsx advised
% User much specify the path location and modify the P1 and P2 fit values
% if multiple NMR points were taken over a long test.
% 

NMR = importdata(['C:\Users\Kevin\Documents\Graduate_Work_MAIN\Electrochemistry\Data\AuFoil Tests\191106AuFoil13ps\AuFoil13NMRdata.xlsx']); %
NMR.time(:,1) = NMR.data(:,1)*60;
% NMR.Acetate = 50*(500/400)*(NMR.data(:,4)/3)./(NMR.data(:,3)/6)*CatholyteVol/(1000000*1000);

%%
% Analysis for Formic Acid
NMR.formic = 50*(500/400)*(NMR.data(:,2)/1)./(NMR.data(:,3)/6)*CatholyteVol/(1000000*1000); %for formic acid NMR
if length(NMR.data(:,1)) == 1 %only one NMR for the experiment
    CompiledData(:,5) = (NMR.formic/(NMR.time(1,1)))  /  molarflow;
else
    P1 = 3e-9; %linear portion user modified
    P2 = 1.6e-11; %log portion user modified
    Formicfit = P1*(ExpTime')+P2*log(ExpTime');
    figure
    plot(NMR.time, NMR.formic,'o',ExpTime, Formicfit)
    title('Formic Fit')
    
    for i = 1:length(Formicfit)-1 %finding the local slope
        CompiledData(i,5) = ((Formicfit(i+1)-Formicfit(i)) / (ExpTime(i+1)-ExpTime(i))) / molarflow;
    end
     CompiledData(length(Formicfit),5) = CompiledData(length(Formicfit)-1,5);
end
%%
% Analysis for EtOH
if length(NMR.data(1,:)) >= 4 && Prodnum >= 6
    NMR.EtOH = 50*(500/400)*(NMR.data(:,4)/3)./(NMR.data(:,3)/6)*CatholyteVol/(1000000*1000); %for EtOH NMR
    if length(NMR.data(:,1)) == 1 %only one NMR for the experiment
        CompiledData(:,6) = (NMR.EtOH/(NMR.time(1,1)))  /  molarflow;
    else
        P1 = 2.5e-10; %linear portion user modified
        P2 = 2.5e-11; %log portion user modified
        EtOHfit = P1*(ExpTime')+P2*log(ExpTime');
        figure
        plot(NMR.time, NMR.EtOH,'o',ExpTime, EtOHfit)
        title('EtOH Fit')

        for i = 1:length(Formicfit)-1 %finding the local slope
            CompiledData(i,6) = ((EtOHfit(i+1)-EtOHfit(i)) / (ExpTime(i+1)-ExpTime(i))) / molarflow;
        end
         CompiledData(length(EtOHfit),6) = CompiledData(length(EtOHfit)-1,6);
    end
else
end
%% Converting to ratio and FE
% convert all x_i to i to ratio
% 
%
CompiledData_xin= (CompiledData'.*n')'; %number of electrons used per product
CompiledData_i = CompiledData_xin * F * v;
CompiledData_itotal(:,1) = sum(CompiledData_i,2); %setting total in col6
CompiledData_ratio(:,1:Prodnum) =  CompiledData_i(:,1:Prodnum)./CompiledData_itotal(:,1); %convert to ratios *psuedo FE*


%% EC Data analysis
% 
% User must specify the file pathway for the EC data. 
% This section will take EC data and average the currents based on each GC
% run section specified in the previous sections. Averaged current can be
% visualized in the plotted data.
%
% _If ECdata file is very large, you may want to same the ECdata in a .mat
% file and then load it each time the code is run._
% 

%% ECdata filtering for 1 ECdata set
% comment out if processed in separate script

ECdata = importdata(['C:\Users\Kevin\Documents\Graduate_Work_MAIN\Electrochemistry\Data\AuFoil Tests\191106AuFoil13ps\ECdata\AuFoil13ECdata.xlsx']);
% save('ECdata.mat','ECdata');
len = length(ECdata.data);
%% Filtering Current
if pulsing == true
    filtered = zeros(round(len/20),2); %% rounds up, divides length by number of GC samples taken during part, makes a matrix of zeros with two columns
    ct = 1; % initializing the counter
    for i = 1:len
        % finding faradaic current
        if ECdata.data(i,2) < -0.3 && ECdata.data(i,2) > -0.7 %% taking current data that is negative but not huge negative charging spikes. this value will change based on case
            filtered(ct,:) = ECdata.data(i,:); % adding cathodic Faradaic current data to new matrix
            ct = ct +1;
        else
        end
    end
    AllECdata = filtered;
else
    AllECdata = ECdata.data;
end
%% If multiple part load data:
% _comment out this section if only one ECdata set._

%     load('CuFoil168TotalECdata.mat');
%     AllECdata = data;

AllECdata(:,1) = AllECdata(:,1) - AllECdata(1,1);  % scaling the time to start at 0
AllECdata(:,1) = AllECdata(:,1)/60; %converting to minutes
if pulsing == true
    AllECdata(:,2) = AllECdata(:,2)/(2); %half the current (equal pulse), density (mA/cm^2)
else
end
GC1strun_starttime = 10; %minutes
GCrunrest_time = 24; %min

figure
hold all;
plot(AllECdata(:,1),AllECdata(:,2))

GCtotrun = floor((AllECdata(end,1) - GCstartdelay)./(GCrunrest)); %calc how many GC runs are in the EC dataset
count = 0; %keep track of which GC count to average
tempaverage = 0; %need to temporarily store all current values
AvgIdiscretized = zeros(GCtotrun,3); %1st col count, 2nd col is sample time, 3rd col is avg current

for i = 1:GCtotrun
    AvgIdiscretized(i,1) = i;
    if i == 1
        [val,endidx]=min(abs(AllECdata(:,1)-GCstartdelay)); %first GC run is avg I from t=0 to GCstartdelay
        AvgIdiscretized(i,2) = AllECdata(endidx,1); %document sample time point
        AvgIdiscretized(i,3) =  mean(AllECdata(1:endidx,2)); %calculating the avg current
    else
        [val,startidx]=min(abs(AllECdata(:,1)-(GCstartdelay+GCrunrest*(i-2))));  %start time and index
        [val,endidx]=min(abs(AllECdata(:,1)-(GCstartdelay+GCrunrest*(i-1)))); %end time (sample point) and index
        AvgIdiscretized(i,2) = AllECdata(endidx,1); %document sample time point
        AvgIdiscretized(i,3) = mean(AllECdata(startidx:endidx,2)); %calculating the Avg current
    end
end
   
if Len > length(AvgIdiscretized)
    for x = 1:(Len-length(AvgIdiscretized))
        AvgIdiscretized(i+x,1) = AvgIdiscretized(i,1)+1*x;
        AvgIdiscretized(i+x,2) = AvgIdiscretized(i,2)+GCrunrest*x;
        AvgIdiscretized(i+x,3) = AvgIdiscretized(i,3);
    end
elseif Len < length(AvgIdiscretized)
    AvgIdiscretized = AvgIdiscretized(1:Len,:);
else
end
    
plot(AvgIdiscretized(:,2),AvgIdiscretized(:,3),'o')
filtCurrent = AvgIdiscretized(:,3);

%% Final Analysis: Ratio, FE, and Partial Current Density
% 
% This section will take all of the GC, NMR, and EC data to calculate the FE
% and partial current densities, plotted
% 

fitvol = TotalFE_fitvol(115, flowrate, Len, AvgIdiscretized, CompiledData_xin, SampMol);

sampleTime = fitvol/(flowrate/60);
    variedsampleTime = ones(Len,1) * sampleTime;
    variedsampleTime(1) = 50/(flowrate/60); %initial adjustments
    % variedsampleTime(2) = 150/(flowrate/60);
    % variedsampleTime(3) = 148/(flowrate/60); %delayed FID06
    % variedsampleTime(7) = 128/(flowrate/60);

    e_in = abs(AvgIdiscretized(:,3)).*variedsampleTime/(96485*1000); %converting to e in
    CompiledData_FE = 100*CompiledData_xin * SampMol ./ e_in; %calculating FE
    CompiledData_totalFE = sum(CompiledData_FE,2); %total FE

    %plotting the moving average
    AvgFitTime = (ExpTime(1):ExpTime(end))'; 
    toAvgFitFE = CompiledData_FE; 
    
    InterpedtoAvgFitFE = zeros(length(AvgFitTime) , length(CompiledData_FE(1,:))); %defining, modified below
    AvgFitFE = InterpedtoAvgFitFE; %defining, modified below
        for ct = 1:5
            InterpedtoAvgFitFE(:,ct) = interp1(ExpTime',CompiledData_FE(:,ct),AvgFitTime);
             if ct == 1
             AvgFitFE(:,ct) = smooth(InterpedtoAvgFitFE(:,ct),0.6,'loess'); %change the value to choose level of moving average
             else
             AvgFitFE(:,ct) = smooth(InterpedtoAvgFitFE(:,ct),0.6,'loess');
             end
        end

%%
% Plotting ratios
figure
hold all
    for ct = 1:Prodnum
        plot(ExpTime, CompiledData_ratio(:,ct),'Linewidth',2,'Color',product_colors(ct,:))
    end
% plot(ExpTime, CompiledData_totalFE(:,1),'Linewidth',2)
title([electrode_name, ' ', exp_parameters, ' Ratio'])
ylim([0 1])
xlabel('Time (min)')
ylabel('Product ratio')
box('on')
legend(products)
savefig([electrode_name, '_', exp_parameters, '_ratios.fig']) %save the figure ratio

%%
% Plotting FEs and saving both FE values and moving averages
figure
hold all
    for ct = 1:Prodnum
        plot(ExpTime, toAvgFitFE(:,ct),'.','MarkerSize',50,'Color',product_colors(ct,:))
        plot(AvgFitTime, AvgFitFE(:,ct),'Linewidth',2,'Color',product_colors(ct,:))
    end
%     plot(ExpTime, AvgFitFE(:,1),'Linewidth',2)
    toAvgFitFE_totalFE = sum(toAvgFitFE,2); %total FE
        plot(ExpTime, toAvgFitFE_totalFE(:,1),'Linewidth',2,'Color',[0 0 0])
    title([electrode_name, ' ', exp_parameters, ' FE'])
    ylim([0 115])
    doubleproducts = [products products];
    for n = 1:2:length(products)*2
        doubleproducts(n:n+1) = [products((n+1)/2)];
    end
legend(doubleproducts,'total FE')
xlabel('Time (min)')
ylabel('Faradaic efficiency (%)')
box('on')
csvwrite([electrode_name, '_', exp_parameters, '_FEprocessed.csv'],[ExpTime' toAvgFitFE toAvgFitFE_totalFE])
csvwrite([electrode_name, '_', exp_parameters, '_FE_movingAvg_processed.csv'],[AvgFitTime AvgFitFE])
savefig([electrode_name, '_', exp_parameters, '_FE.fig']) 

%%
% Plotting current densities and saving current densities
figure
hold all
CurrentDensities = [ExpTime' toAvgFitFE filtCurrent/Area]; %defining to modify, not averaged smoothed 

    for ct = 1:Prodnum
    plot(ExpTime', filtCurrent.*(toAvgFitFE(:,ct)/100)/Area,'Linewidth',2,'Color',product_colors(ct,:))
    CurrentDensities(:,ct+1) = filtCurrent.*(toAvgFitFE(:,ct)/100)/Area;
    end
    plot(ExpTime', filtCurrent/Area,'Linewidth',2,'Color',[0 0 0])
    title([electrode_name, ' ', exp_parameters, ' partial Current Density'])
xlabel('Time (min)')
ylabel('j_i (mA/cm^2)')
box('on')
legend(products)
csvwrite([electrode_name, '_', exp_parameters, '_PartialCurrentprocessed.csv'],abs(CurrentDensities))
savefig([electrode_name, '_', exp_parameters, '_CurrentDensities.fig'])
    
%%
function Area = H2peak1AreaFinder(H2peak1location, time, GCdata)
[val,idx]=min(abs(time-H2peak1location)); %finding the index for Peak position
    %make all data of interest positive
    if min(GCdata((idx-30):(idx+50))) < 0
        shiftup = abs(min(GCdata((idx-30):(idx+50))));
    else
        shiftup = 0;
    end
    
    if GCdata(idx) < 8000
        Rightin = 20;
        Rightout = 50;
    else
        Rightin = 30;
        Rightout = 50;
    end
tpseudo = [time((idx-30):(idx-18)),time((idx+Rightin):(idx+Rightout))];
datapseudo = [GCdata((idx-30):(idx-18)),GCdata((idx+Rightin):(idx+Rightout))];
timeH2 = time((idx-30):(idx+Rightout)); %all time
P = polyfit(tpseudo,datapseudo,4); %3rd order polyfit
yfit = P(1)*timeH2.^4+P(2)*timeH2.^3+P(3)*timeH2.^2+P(4)*timeH2+P(5);
BaselineArea = trapz(timeH2, yfit+shiftup);
H2peak1Area = trapz(time((idx-30):(idx+Rightout)), shiftup+GCdata((idx-30):(idx+Rightout)));
Area = H2peak1Area - BaselineArea;
    figure
    hold all
    area(time((idx-30):(idx+Rightout)), shiftup+GCdata((idx-30):(idx+Rightout)))
    area(timeH2, yfit+shiftup)
    title(['H2 peak 1 Rightin',num2str(Rightin)])
end

%%
function Area = CH4peak1AreaFinder(CH4peak1location, time, GCdata)
[val,idx] = min(abs(time-CH4peak1location)); %finding the index for Peak position

    %make all data of interest positive
    if min(GCdata((idx-200):(idx+180))) < 0
        shiftup = abs(min(GCdata((idx-200):(idx+180)))); %take absolute value
    else
        shiftup = 0;
    end
    
    if GCdata(idx) < 8000
        Rightin = 80;
        Rightout = 150;
    else
        Rightin = 150;
        Rightout = 200;
    end
    
tpseudo = [time((idx-200):(idx-150)),time((idx+Rightin):(idx+Rightout))];
datapseudo = [GCdata((idx-200):(idx-150)),GCdata((idx+Rightin):(idx+Rightout))];
P = polyfit(tpseudo,datapseudo,1);
yfit = P(1)*tpseudo+P(2);
BaselineArea = trapz(tpseudo, yfit+shiftup);
CH4peak1Area = trapz(time((idx-200):(idx+Rightout)), GCdata((idx-200):(idx+Rightout))+shiftup);
Area = CH4peak1Area - BaselineArea;
    if Area < 5 %empirically found, below threshold of actual peak
        Area = 0;
    else
    figure %graphing to check fit
    hold all
    area(time((idx-200):(idx+Rightout)), GCdata((idx-200):(idx+Rightout))+shiftup)
    area(tpseudo, yfit+shiftup)
    title(['CH4 peak 1',num2str(Rightin)])
    end
end
%%
function Area = COpeak1AreaFinder(COpeak1location, time, GCdata)
[val,idx]=min(abs(time-COpeak1location)); %finding the index for Peak position
    %make all data of interest positive
    if min(GCdata((idx-200):(idx+200))) < 0
        shiftup = abs(min(GCdata((idx-200):(idx+200)))); %take absolute value
    else
        shiftup = 0;
    end
tpseudo = [time((idx-200):(idx-150)),time((idx+150):(idx+200))];
datapseudo = [GCdata((idx-200):(idx-150)),GCdata((idx+150):(idx+200))];
P = polyfit(tpseudo,datapseudo,2);
yfit = P(1)*tpseudo.^2+P(2)*tpseudo+P(3);
BaselineArea = trapz(tpseudo, yfit+shiftup);
COpeak1Area = trapz(time((idx-200):(idx+200)), GCdata((idx-200):(idx+200))+shiftup);
Area = COpeak1Area - BaselineArea;
    figure %graphing to double check fit
    hold all
    area(time((idx-150):(idx+150)), GCdata((idx-150):(idx+150))+shiftup)
    area(tpseudo, yfit+shiftup)
    title('CO peak 1')
end
%%
function Area = CH4peak2AreaFinder(CH4peak2location, time, GCdata, OutLeft, InLeft, InRight, OutRight)
[val,idx]=min(abs(time-CH4peak2location)); %finding the index for Peak position
    %make all data of interest positive
    if min(GCdata((idx-OutLeft):(idx+OutRight))) < 0
        shiftup = abs(min(GCdata((idx-OutLeft):(idx+OutRight)))); %take absolute value
    else
        shiftup = 0;
    end
tpseudo = [time((idx-OutLeft):(idx-InLeft)),time((idx+InRight):(idx+OutRight))]; %time span of interest for peak
datapseudo = [GCdata((idx-OutLeft):(idx-InLeft)),GCdata((idx+InRight):(idx+OutRight))]; %GCdata span of interest for peak
timeCH4 = time((idx-OutLeft):(idx+OutRight)); %all time
P = polyfit(tpseudo,datapseudo,2); % calculating quadratic fit
yfit = P(1)*timeCH4.^2+P(2)*timeCH4+P(3); %quadratic fit for baseline
BaselineArea = trapz(timeCH4, yfit+shiftup); %ares of baseline
CH4peak2Area = trapz(time((idx-OutLeft):(idx+OutRight)), GCdata((idx-OutLeft):(idx+OutRight))+shiftup);
Area = CH4peak2Area - BaselineArea;
    if Area < 10 %empirically found, below threshold of actual peak
        Area = 0;
    else
    figure
    hold all
    area(time((idx-OutLeft):(idx+OutRight)), GCdata((idx-OutLeft):(idx+OutRight))+shiftup)
    area(timeCH4, yfit+shiftup)
    title('CH4 peak 2')
    end
end
%%
function Area = C2H4peak1AreaFinder(C2H4peak1location, time, GCdata,OutLeft, InLeft, InRight, OutRight)
[val,idx]=min(abs(time-C2H4peak1location)); %finding the index for Peak position
    %make all data of interest positive
    if min(GCdata((idx-OutLeft):(idx+OutRight))) < 0
        shiftup = abs(min(GCdata((idx-OutLeft):(idx+OutRight)))); %take absolute value
    else
        shiftup = 0;
    end
tpseudo = [time((idx-OutLeft):(idx-InLeft)),time((idx+InRight):(idx+OutRight))];
datapseudo = [GCdata((idx-OutLeft):(idx-InLeft)),GCdata((idx+InRight):(idx+OutRight))];
timeC2H4 = time((idx-OutLeft):(idx+OutRight));
% dataC2H4 = GCdata((idx-200):(idx+200));
P = polyfit(tpseudo,datapseudo,2);
yfit = P(1)*timeC2H4.^2+P(2)*timeC2H4+P(3);
BaselineArea = trapz(timeC2H4, yfit+shiftup); %ares of baseline
C2H4peak1Area = trapz(time((idx-OutLeft):(idx+OutRight)), GCdata((idx-OutLeft):(idx+OutRight))+shiftup);
Area = C2H4peak1Area - BaselineArea;
    if Area < 120 %empirically found, below threshold of actual peak
        Area = 0;
    else
        figure
        hold all
        area(time((idx-OutLeft+20):(idx+OutRight)), GCdata((idx-OutLeft+20):(idx+OutRight))+shiftup)
        area(timeC2H4(20:end), yfit(20:end)+shiftup)
        title('C2H4 peak 1')
    end

end

%%
function fitvol = TotalFE_fitvol(initialguess, flowrate, Len, AvgIdiscretized, CompiledData_xin, SampMol)
    %id best sample time
        fitvol = initialguess; %initial guess
        sampleTime = fitvol/(flowrate/60);
        variedsampleTime = ones(Len,1) * sampleTime;
        e_in = abs(AvgIdiscretized(:,3)).*variedsampleTime/(96485*1000); %converting to e in
        CompiledData_FE = 100*CompiledData_xin * SampMol ./ e_in; %calculating FE
        CompiledData_totalFE = sum(CompiledData_FE,2); %total FE
        baseline_diff = abs(100-CompiledData_totalFE(end));

    for test = 1:100
        newfitvol = 85 + 60*rand();
        sampleTime = newfitvol/(flowrate/60);
        variedsampleTime = ones(Len,1) * sampleTime;
        e_in = abs(AvgIdiscretized(:,3)).*variedsampleTime/(96485*1000); %converting to e in
        CompiledData_FE = 100*CompiledData_xin * SampMol ./ e_in; %calculating FE
        CompiledData_totalFE = sum(CompiledData_FE,2); %total FE
        if abs(100-CompiledData_totalFE(end)) < baseline_diff
            fitvol = newfitvol;
            baseline_diff = abs(100-CompiledData_totalFE(end));
        else 
        end
    end
end